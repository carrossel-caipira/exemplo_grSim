// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssl_simulation_config.proto

#include "ssl_simulation_config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR RobotLimits::RobotLimits(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.acc_speedup_absolute_max_)*/0
  , /*decltype(_impl_.acc_speedup_angular_max_)*/0
  , /*decltype(_impl_.acc_brake_absolute_max_)*/0
  , /*decltype(_impl_.acc_brake_angular_max_)*/0
  , /*decltype(_impl_.vel_absolute_max_)*/0
  , /*decltype(_impl_.vel_angular_max_)*/0} {}
struct RobotLimitsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotLimitsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotLimitsDefaultTypeInternal() {}
  union {
    RobotLimits _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotLimitsDefaultTypeInternal _RobotLimits_default_instance_;
PROTOBUF_CONSTEXPR RobotWheelAngles::RobotWheelAngles(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.front_right_)*/0
  , /*decltype(_impl_.back_right_)*/0
  , /*decltype(_impl_.back_left_)*/0
  , /*decltype(_impl_.front_left_)*/0} {}
struct RobotWheelAnglesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotWheelAnglesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotWheelAnglesDefaultTypeInternal() {}
  union {
    RobotWheelAngles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotWheelAnglesDefaultTypeInternal _RobotWheelAngles_default_instance_;
PROTOBUF_CONSTEXPR RobotSpecs::RobotSpecs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/nullptr
  , /*decltype(_impl_.limits_)*/nullptr
  , /*decltype(_impl_.wheel_angles_)*/nullptr
  , /*decltype(_impl_.custom_)*/nullptr
  , /*decltype(_impl_.mass_)*/0
  , /*decltype(_impl_.max_linear_kick_speed_)*/0
  , /*decltype(_impl_.max_chip_kick_speed_)*/0
  , /*decltype(_impl_.center_to_dribbler_)*/0
  , /*decltype(_impl_.radius_)*/0.09f
  , /*decltype(_impl_.height_)*/0.15f} {}
struct RobotSpecsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotSpecsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotSpecsDefaultTypeInternal() {}
  union {
    RobotSpecs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotSpecsDefaultTypeInternal _RobotSpecs_default_instance_;
PROTOBUF_CONSTEXPR RealismConfig::RealismConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.custom_)*/nullptr} {}
struct RealismConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RealismConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RealismConfigDefaultTypeInternal() {}
  union {
    RealismConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RealismConfigDefaultTypeInternal _RealismConfig_default_instance_;
PROTOBUF_CONSTEXPR SimulatorConfig::SimulatorConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.robot_specs_)*/{}
  , /*decltype(_impl_.geometry_)*/nullptr
  , /*decltype(_impl_.realism_config_)*/nullptr
  , /*decltype(_impl_.vision_port_)*/0u} {}
struct SimulatorConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SimulatorConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SimulatorConfigDefaultTypeInternal() {}
  union {
    SimulatorConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SimulatorConfigDefaultTypeInternal _SimulatorConfig_default_instance_;
static ::_pb::Metadata file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[5];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_ssl_5fsimulation_5fconfig_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_ssl_5fsimulation_5fconfig_2eproto = nullptr;

const uint32_t TableStruct_ssl_5fsimulation_5fconfig_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _impl_.acc_speedup_absolute_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _impl_.acc_speedup_angular_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _impl_.acc_brake_absolute_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _impl_.acc_brake_angular_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _impl_.vel_absolute_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _impl_.vel_angular_max_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, _impl_.front_right_),
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, _impl_.back_right_),
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, _impl_.back_left_),
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, _impl_.front_left_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.mass_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.max_linear_kick_speed_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.max_chip_kick_speed_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.center_to_dribbler_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.limits_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.wheel_angles_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _impl_.custom_),
  0,
  8,
  9,
  4,
  5,
  6,
  7,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::RealismConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::RealismConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RealismConfig, _impl_.custom_),
  0,
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, _impl_.geometry_),
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, _impl_.robot_specs_),
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, _impl_.realism_config_),
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, _impl_.vision_port_),
  0,
  ~0u,
  1,
  2,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::RobotLimits)},
  { 18, 28, -1, sizeof(::RobotWheelAngles)},
  { 32, 48, -1, sizeof(::RobotSpecs)},
  { 58, 65, -1, sizeof(::RealismConfig)},
  { 66, 76, -1, sizeof(::SimulatorConfig)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_RobotLimits_default_instance_._instance,
  &::_RobotWheelAngles_default_instance_._instance,
  &::_RobotSpecs_default_instance_._instance,
  &::_RealismConfig_default_instance_._instance,
  &::_SimulatorConfig_default_instance_._instance,
};

const char descriptor_table_protodef_ssl_5fsimulation_5fconfig_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\033ssl_simulation_config.proto\032\023ssl_gc_co"
  "mmon.proto\032\031ssl_vision_geometry.proto\032\031g"
  "oogle/protobuf/any.proto\"\302\001\n\013RobotLimits"
  "\022 \n\030acc_speedup_absolute_max\030\001 \001(\002\022\037\n\027ac"
  "c_speedup_angular_max\030\002 \001(\002\022\036\n\026acc_brake"
  "_absolute_max\030\003 \001(\002\022\035\n\025acc_brake_angular"
  "_max\030\004 \001(\002\022\030\n\020vel_absolute_max\030\005 \001(\002\022\027\n\017"
  "vel_angular_max\030\006 \001(\002\"b\n\020RobotWheelAngle"
  "s\022\023\n\013front_right\030\001 \002(\002\022\022\n\nback_right\030\002 \002"
  "(\002\022\021\n\tback_left\030\003 \002(\002\022\022\n\nfront_left\030\004 \002("
  "\002\"\241\002\n\nRobotSpecs\022\024\n\002id\030\001 \002(\0132\010.RobotId\022\024"
  "\n\006radius\030\002 \001(\002:\0040.09\022\024\n\006height\030\003 \001(\002:\0040."
  "15\022\014\n\004mass\030\004 \001(\002\022\035\n\025max_linear_kick_spee"
  "d\030\007 \001(\002\022\033\n\023max_chip_kick_speed\030\010 \001(\002\022\032\n\022"
  "center_to_dribbler\030\t \001(\002\022\034\n\006limits\030\n \001(\013"
  "2\014.RobotLimits\022\'\n\014wheel_angles\030\r \001(\0132\021.R"
  "obotWheelAngles\022$\n\006custom\030\016 \001(\0132\024.google"
  ".protobuf.Any\"5\n\rRealismConfig\022$\n\006custom"
  "\030\001 \001(\0132\024.google.protobuf.Any\"\225\001\n\017Simulat"
  "orConfig\022#\n\010geometry\030\001 \001(\0132\021.SSL_Geometr"
  "yData\022 \n\013robot_specs\030\002 \003(\0132\013.RobotSpecs\022"
  "&\n\016realism_config\030\003 \001(\0132\016.RealismConfig\022"
  "\023\n\013vision_port\030\004 \001(\rB8Z6github.com/RoboC"
  "up-SSL/ssl-simulation-protocol/pkg/sim"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_ssl_5fsimulation_5fconfig_2eproto_deps[3] = {
  &::descriptor_table_google_2fprotobuf_2fany_2eproto,
  &::descriptor_table_ssl_5fgc_5fcommon_2eproto,
  &::descriptor_table_ssl_5fvision_5fgeometry_2eproto,
};
static ::_pbi::once_flag descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ssl_5fsimulation_5fconfig_2eproto = {
    false, false, 958, descriptor_table_protodef_ssl_5fsimulation_5fconfig_2eproto,
    "ssl_simulation_config.proto",
    &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once, descriptor_table_ssl_5fsimulation_5fconfig_2eproto_deps, 3, 5,
    schemas, file_default_instances, TableStruct_ssl_5fsimulation_5fconfig_2eproto::offsets,
    file_level_metadata_ssl_5fsimulation_5fconfig_2eproto, file_level_enum_descriptors_ssl_5fsimulation_5fconfig_2eproto,
    file_level_service_descriptors_ssl_5fsimulation_5fconfig_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter() {
  return &descriptor_table_ssl_5fsimulation_5fconfig_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ssl_5fsimulation_5fconfig_2eproto(&descriptor_table_ssl_5fsimulation_5fconfig_2eproto);

// ===================================================================

class RobotLimits::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotLimits>()._impl_._has_bits_);
  static void set_has_acc_speedup_absolute_max(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_acc_speedup_angular_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_acc_brake_absolute_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_acc_brake_angular_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vel_absolute_max(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_vel_angular_max(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

RobotLimits::RobotLimits(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RobotLimits)
}
RobotLimits::RobotLimits(const RobotLimits& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RobotLimits* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.acc_speedup_absolute_max_){}
    , decltype(_impl_.acc_speedup_angular_max_){}
    , decltype(_impl_.acc_brake_absolute_max_){}
    , decltype(_impl_.acc_brake_angular_max_){}
    , decltype(_impl_.vel_absolute_max_){}
    , decltype(_impl_.vel_angular_max_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.acc_speedup_absolute_max_, &from._impl_.acc_speedup_absolute_max_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vel_angular_max_) -
    reinterpret_cast<char*>(&_impl_.acc_speedup_absolute_max_)) + sizeof(_impl_.vel_angular_max_));
  // @@protoc_insertion_point(copy_constructor:RobotLimits)
}

inline void RobotLimits::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.acc_speedup_absolute_max_){0}
    , decltype(_impl_.acc_speedup_angular_max_){0}
    , decltype(_impl_.acc_brake_absolute_max_){0}
    , decltype(_impl_.acc_brake_angular_max_){0}
    , decltype(_impl_.vel_absolute_max_){0}
    , decltype(_impl_.vel_angular_max_){0}
  };
}

RobotLimits::~RobotLimits() {
  // @@protoc_insertion_point(destructor:RobotLimits)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RobotLimits::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RobotLimits::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RobotLimits::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotLimits)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.acc_speedup_absolute_max_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vel_angular_max_) -
        reinterpret_cast<char*>(&_impl_.acc_speedup_absolute_max_)) + sizeof(_impl_.vel_angular_max_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotLimits::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float acc_speedup_absolute_max = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_acc_speedup_absolute_max(&has_bits);
          _impl_.acc_speedup_absolute_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float acc_speedup_angular_max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_acc_speedup_angular_max(&has_bits);
          _impl_.acc_speedup_angular_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float acc_brake_absolute_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_acc_brake_absolute_max(&has_bits);
          _impl_.acc_brake_absolute_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float acc_brake_angular_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_acc_brake_angular_max(&has_bits);
          _impl_.acc_brake_angular_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float vel_absolute_max = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_vel_absolute_max(&has_bits);
          _impl_.vel_absolute_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float vel_angular_max = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_vel_angular_max(&has_bits);
          _impl_.vel_angular_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotLimits::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotLimits)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float acc_speedup_absolute_max = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_acc_speedup_absolute_max(), target);
  }

  // optional float acc_speedup_angular_max = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_acc_speedup_angular_max(), target);
  }

  // optional float acc_brake_absolute_max = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_acc_brake_absolute_max(), target);
  }

  // optional float acc_brake_angular_max = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_acc_brake_angular_max(), target);
  }

  // optional float vel_absolute_max = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_vel_absolute_max(), target);
  }

  // optional float vel_angular_max = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_vel_angular_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotLimits)
  return target;
}

size_t RobotLimits::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RobotLimits)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional float acc_speedup_absolute_max = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float acc_speedup_angular_max = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float acc_brake_absolute_max = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float acc_brake_angular_max = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float vel_absolute_max = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float vel_angular_max = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotLimits::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RobotLimits::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotLimits::GetClassData() const { return &_class_data_; }


void RobotLimits::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RobotLimits*>(&to_msg);
  auto& from = static_cast<const RobotLimits&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RobotLimits)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.acc_speedup_absolute_max_ = from._impl_.acc_speedup_absolute_max_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.acc_speedup_angular_max_ = from._impl_.acc_speedup_angular_max_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.acc_brake_absolute_max_ = from._impl_.acc_brake_absolute_max_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.acc_brake_angular_max_ = from._impl_.acc_brake_angular_max_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.vel_absolute_max_ = from._impl_.vel_absolute_max_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.vel_angular_max_ = from._impl_.vel_angular_max_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotLimits::CopyFrom(const RobotLimits& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotLimits)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotLimits::IsInitialized() const {
  return true;
}

void RobotLimits::InternalSwap(RobotLimits* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotLimits, _impl_.vel_angular_max_)
      + sizeof(RobotLimits::_impl_.vel_angular_max_)
      - PROTOBUF_FIELD_OFFSET(RobotLimits, _impl_.acc_speedup_absolute_max_)>(
          reinterpret_cast<char*>(&_impl_.acc_speedup_absolute_max_),
          reinterpret_cast<char*>(&other->_impl_.acc_speedup_absolute_max_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotLimits::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[0]);
}

// ===================================================================

class RobotWheelAngles::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotWheelAngles>()._impl_._has_bits_);
  static void set_has_front_right(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_back_right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_back_left(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_front_left(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

RobotWheelAngles::RobotWheelAngles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RobotWheelAngles)
}
RobotWheelAngles::RobotWheelAngles(const RobotWheelAngles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RobotWheelAngles* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.front_right_){}
    , decltype(_impl_.back_right_){}
    , decltype(_impl_.back_left_){}
    , decltype(_impl_.front_left_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.front_right_, &from._impl_.front_right_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.front_left_) -
    reinterpret_cast<char*>(&_impl_.front_right_)) + sizeof(_impl_.front_left_));
  // @@protoc_insertion_point(copy_constructor:RobotWheelAngles)
}

inline void RobotWheelAngles::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.front_right_){0}
    , decltype(_impl_.back_right_){0}
    , decltype(_impl_.back_left_){0}
    , decltype(_impl_.front_left_){0}
  };
}

RobotWheelAngles::~RobotWheelAngles() {
  // @@protoc_insertion_point(destructor:RobotWheelAngles)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RobotWheelAngles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RobotWheelAngles::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RobotWheelAngles::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotWheelAngles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.front_right_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.front_left_) -
        reinterpret_cast<char*>(&_impl_.front_right_)) + sizeof(_impl_.front_left_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotWheelAngles::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float front_right = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_front_right(&has_bits);
          _impl_.front_right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float back_right = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_back_right(&has_bits);
          _impl_.back_right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float back_left = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_back_left(&has_bits);
          _impl_.back_left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float front_left = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_front_left(&has_bits);
          _impl_.front_left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotWheelAngles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotWheelAngles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float front_right = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_front_right(), target);
  }

  // required float back_right = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_back_right(), target);
  }

  // required float back_left = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_back_left(), target);
  }

  // required float front_left = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_front_left(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotWheelAngles)
  return target;
}

size_t RobotWheelAngles::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RobotWheelAngles)
  size_t total_size = 0;

  if (_internal_has_front_right()) {
    // required float front_right = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_back_right()) {
    // required float back_right = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_back_left()) {
    // required float back_left = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_front_left()) {
    // required float front_left = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t RobotWheelAngles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RobotWheelAngles)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float front_right = 1;
    total_size += 1 + 4;

    // required float back_right = 2;
    total_size += 1 + 4;

    // required float back_left = 3;
    total_size += 1 + 4;

    // required float front_left = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotWheelAngles::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RobotWheelAngles::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotWheelAngles::GetClassData() const { return &_class_data_; }


void RobotWheelAngles::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RobotWheelAngles*>(&to_msg);
  auto& from = static_cast<const RobotWheelAngles&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RobotWheelAngles)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.front_right_ = from._impl_.front_right_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.back_right_ = from._impl_.back_right_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.back_left_ = from._impl_.back_left_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.front_left_ = from._impl_.front_left_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotWheelAngles::CopyFrom(const RobotWheelAngles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotWheelAngles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotWheelAngles::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void RobotWheelAngles::InternalSwap(RobotWheelAngles* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotWheelAngles, _impl_.front_left_)
      + sizeof(RobotWheelAngles::_impl_.front_left_)
      - PROTOBUF_FIELD_OFFSET(RobotWheelAngles, _impl_.front_right_)>(
          reinterpret_cast<char*>(&_impl_.front_right_),
          reinterpret_cast<char*>(&other->_impl_.front_right_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotWheelAngles::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[1]);
}

// ===================================================================

class RobotSpecs::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotSpecs>()._impl_._has_bits_);
  static const ::RobotId& id(const RobotSpecs* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_mass(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_linear_kick_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_chip_kick_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_center_to_dribbler(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::RobotLimits& limits(const RobotSpecs* msg);
  static void set_has_limits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::RobotWheelAngles& wheel_angles(const RobotSpecs* msg);
  static void set_has_wheel_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Any& custom(const RobotSpecs* msg);
  static void set_has_custom(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::RobotId&
RobotSpecs::_Internal::id(const RobotSpecs* msg) {
  return *msg->_impl_.id_;
}
const ::RobotLimits&
RobotSpecs::_Internal::limits(const RobotSpecs* msg) {
  return *msg->_impl_.limits_;
}
const ::RobotWheelAngles&
RobotSpecs::_Internal::wheel_angles(const RobotSpecs* msg) {
  return *msg->_impl_.wheel_angles_;
}
const ::PROTOBUF_NAMESPACE_ID::Any&
RobotSpecs::_Internal::custom(const RobotSpecs* msg) {
  return *msg->_impl_.custom_;
}
void RobotSpecs::clear_id() {
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RobotSpecs::clear_custom() {
  if (_impl_.custom_ != nullptr) _impl_.custom_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
RobotSpecs::RobotSpecs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RobotSpecs)
}
RobotSpecs::RobotSpecs(const RobotSpecs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RobotSpecs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){nullptr}
    , decltype(_impl_.limits_){nullptr}
    , decltype(_impl_.wheel_angles_){nullptr}
    , decltype(_impl_.custom_){nullptr}
    , decltype(_impl_.mass_){}
    , decltype(_impl_.max_linear_kick_speed_){}
    , decltype(_impl_.max_chip_kick_speed_){}
    , decltype(_impl_.center_to_dribbler_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.height_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    _this->_impl_.id_ = new ::RobotId(*from._impl_.id_);
  }
  if (from._internal_has_limits()) {
    _this->_impl_.limits_ = new ::RobotLimits(*from._impl_.limits_);
  }
  if (from._internal_has_wheel_angles()) {
    _this->_impl_.wheel_angles_ = new ::RobotWheelAngles(*from._impl_.wheel_angles_);
  }
  if (from._internal_has_custom()) {
    _this->_impl_.custom_ = new ::PROTOBUF_NAMESPACE_ID::Any(*from._impl_.custom_);
  }
  ::memcpy(&_impl_.mass_, &from._impl_.mass_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.mass_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:RobotSpecs)
}

inline void RobotSpecs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){nullptr}
    , decltype(_impl_.limits_){nullptr}
    , decltype(_impl_.wheel_angles_){nullptr}
    , decltype(_impl_.custom_){nullptr}
    , decltype(_impl_.mass_){0}
    , decltype(_impl_.max_linear_kick_speed_){0}
    , decltype(_impl_.max_chip_kick_speed_){0}
    , decltype(_impl_.center_to_dribbler_){0}
    , decltype(_impl_.radius_){0.09f}
    , decltype(_impl_.height_){0.15f}
  };
}

RobotSpecs::~RobotSpecs() {
  // @@protoc_insertion_point(destructor:RobotSpecs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RobotSpecs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.id_;
  if (this != internal_default_instance()) delete _impl_.limits_;
  if (this != internal_default_instance()) delete _impl_.wheel_angles_;
  if (this != internal_default_instance()) delete _impl_.custom_;
}

void RobotSpecs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RobotSpecs::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotSpecs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.id_ != nullptr);
      _impl_.id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.limits_ != nullptr);
      _impl_.limits_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.wheel_angles_ != nullptr);
      _impl_.wheel_angles_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.custom_ != nullptr);
      _impl_.custom_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.mass_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.center_to_dribbler_) -
        reinterpret_cast<char*>(&_impl_.mass_)) + sizeof(_impl_.center_to_dribbler_));
  }
  if (cached_has_bits & 0x00000300u) {
    _impl_.radius_ = 0.09f;
    _impl_.height_ = 0.15f;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotSpecs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .RobotId id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float radius = 2 [default = 0.09];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float height = 3 [default = 0.15];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float mass = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_mass(&has_bits);
          _impl_.mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_linear_kick_speed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_max_linear_kick_speed(&has_bits);
          _impl_.max_linear_kick_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_chip_kick_speed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_max_chip_kick_speed(&has_bits);
          _impl_.max_chip_kick_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float center_to_dribbler = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_center_to_dribbler(&has_bits);
          _impl_.center_to_dribbler_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .RobotLimits limits = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_limits(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .RobotWheelAngles wheel_angles = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_wheel_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Any custom = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotSpecs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotSpecs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .RobotId id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::id(this),
        _Internal::id(this).GetCachedSize(), target, stream);
  }

  // optional float radius = 2 [default = 0.09];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_radius(), target);
  }

  // optional float height = 3 [default = 0.15];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_height(), target);
  }

  // optional float mass = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_mass(), target);
  }

  // optional float max_linear_kick_speed = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_max_linear_kick_speed(), target);
  }

  // optional float max_chip_kick_speed = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_max_chip_kick_speed(), target);
  }

  // optional float center_to_dribbler = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_center_to_dribbler(), target);
  }

  // optional .RobotLimits limits = 10;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::limits(this),
        _Internal::limits(this).GetCachedSize(), target, stream);
  }

  // optional .RobotWheelAngles wheel_angles = 13;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::wheel_angles(this),
        _Internal::wheel_angles(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Any custom = 14;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::custom(this),
        _Internal::custom(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotSpecs)
  return target;
}

size_t RobotSpecs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RobotSpecs)
  size_t total_size = 0;

  // required .RobotId id = 1;
  if (_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.id_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .RobotLimits limits = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.limits_);
    }

    // optional .RobotWheelAngles wheel_angles = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.wheel_angles_);
    }

    // optional .google.protobuf.Any custom = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.custom_);
    }

    // optional float mass = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float max_linear_kick_speed = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float max_chip_kick_speed = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float center_to_dribbler = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional float radius = 2 [default = 0.09];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float height = 3 [default = 0.15];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotSpecs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RobotSpecs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotSpecs::GetClassData() const { return &_class_data_; }


void RobotSpecs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RobotSpecs*>(&to_msg);
  auto& from = static_cast<const RobotSpecs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RobotSpecs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_id()->::RobotId::MergeFrom(
          from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_limits()->::RobotLimits::MergeFrom(
          from._internal_limits());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_wheel_angles()->::RobotWheelAngles::MergeFrom(
          from._internal_wheel_angles());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_custom()->::PROTOBUF_NAMESPACE_ID::Any::MergeFrom(
          from._internal_custom());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mass_ = from._impl_.mass_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.max_linear_kick_speed_ = from._impl_.max_linear_kick_speed_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.max_chip_kick_speed_ = from._impl_.max_chip_kick_speed_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.center_to_dribbler_ = from._impl_.center_to_dribbler_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotSpecs::CopyFrom(const RobotSpecs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotSpecs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotSpecs::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_wheel_angles()) {
    if (!_impl_.wheel_angles_->IsInitialized()) return false;
  }
  return true;
}

void RobotSpecs::InternalSwap(RobotSpecs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotSpecs, _impl_.center_to_dribbler_)
      + sizeof(RobotSpecs::_impl_.center_to_dribbler_)
      - PROTOBUF_FIELD_OFFSET(RobotSpecs, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
  swap(_impl_.radius_, other->_impl_.radius_);
  swap(_impl_.height_, other->_impl_.height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotSpecs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[2]);
}

// ===================================================================

class RealismConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<RealismConfig>()._impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Any& custom(const RealismConfig* msg);
  static void set_has_custom(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Any&
RealismConfig::_Internal::custom(const RealismConfig* msg) {
  return *msg->_impl_.custom_;
}
void RealismConfig::clear_custom() {
  if (_impl_.custom_ != nullptr) _impl_.custom_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RealismConfig::RealismConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RealismConfig)
}
RealismConfig::RealismConfig(const RealismConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RealismConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.custom_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_custom()) {
    _this->_impl_.custom_ = new ::PROTOBUF_NAMESPACE_ID::Any(*from._impl_.custom_);
  }
  // @@protoc_insertion_point(copy_constructor:RealismConfig)
}

inline void RealismConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.custom_){nullptr}
  };
}

RealismConfig::~RealismConfig() {
  // @@protoc_insertion_point(destructor:RealismConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RealismConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.custom_;
}

void RealismConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RealismConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:RealismConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.custom_ != nullptr);
    _impl_.custom_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RealismConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .google.protobuf.Any custom = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RealismConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RealismConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .google.protobuf.Any custom = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::custom(this),
        _Internal::custom(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RealismConfig)
  return target;
}

size_t RealismConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RealismConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .google.protobuf.Any custom = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.custom_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RealismConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RealismConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RealismConfig::GetClassData() const { return &_class_data_; }


void RealismConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RealismConfig*>(&to_msg);
  auto& from = static_cast<const RealismConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RealismConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_custom()) {
    _this->_internal_mutable_custom()->::PROTOBUF_NAMESPACE_ID::Any::MergeFrom(
        from._internal_custom());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RealismConfig::CopyFrom(const RealismConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RealismConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RealismConfig::IsInitialized() const {
  return true;
}

void RealismConfig::InternalSwap(RealismConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.custom_, other->_impl_.custom_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RealismConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[3]);
}

// ===================================================================

class SimulatorConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<SimulatorConfig>()._impl_._has_bits_);
  static const ::SSL_GeometryData& geometry(const SimulatorConfig* msg);
  static void set_has_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::RealismConfig& realism_config(const SimulatorConfig* msg);
  static void set_has_realism_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vision_port(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::SSL_GeometryData&
SimulatorConfig::_Internal::geometry(const SimulatorConfig* msg) {
  return *msg->_impl_.geometry_;
}
const ::RealismConfig&
SimulatorConfig::_Internal::realism_config(const SimulatorConfig* msg) {
  return *msg->_impl_.realism_config_;
}
void SimulatorConfig::clear_geometry() {
  if (_impl_.geometry_ != nullptr) _impl_.geometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SimulatorConfig::SimulatorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SimulatorConfig)
}
SimulatorConfig::SimulatorConfig(const SimulatorConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SimulatorConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.robot_specs_){from._impl_.robot_specs_}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.realism_config_){nullptr}
    , decltype(_impl_.vision_port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_geometry()) {
    _this->_impl_.geometry_ = new ::SSL_GeometryData(*from._impl_.geometry_);
  }
  if (from._internal_has_realism_config()) {
    _this->_impl_.realism_config_ = new ::RealismConfig(*from._impl_.realism_config_);
  }
  _this->_impl_.vision_port_ = from._impl_.vision_port_;
  // @@protoc_insertion_point(copy_constructor:SimulatorConfig)
}

inline void SimulatorConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.robot_specs_){arena}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.realism_config_){nullptr}
    , decltype(_impl_.vision_port_){0u}
  };
}

SimulatorConfig::~SimulatorConfig() {
  // @@protoc_insertion_point(destructor:SimulatorConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SimulatorConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.robot_specs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.geometry_;
  if (this != internal_default_instance()) delete _impl_.realism_config_;
}

void SimulatorConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SimulatorConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:SimulatorConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.robot_specs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.geometry_ != nullptr);
      _impl_.geometry_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.realism_config_ != nullptr);
      _impl_.realism_config_->Clear();
    }
  }
  _impl_.vision_port_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimulatorConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SSL_GeometryData geometry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_geometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .RobotSpecs robot_specs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_robot_specs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .RealismConfig realism_config = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_realism_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 vision_port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_vision_port(&has_bits);
          _impl_.vision_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimulatorConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SimulatorConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SSL_GeometryData geometry = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::geometry(this),
        _Internal::geometry(this).GetCachedSize(), target, stream);
  }

  // repeated .RobotSpecs robot_specs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_robot_specs_size()); i < n; i++) {
    const auto& repfield = this->_internal_robot_specs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .RealismConfig realism_config = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::realism_config(this),
        _Internal::realism_config(this).GetCachedSize(), target, stream);
  }

  // optional uint32 vision_port = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_vision_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SimulatorConfig)
  return target;
}

size_t SimulatorConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SimulatorConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .RobotSpecs robot_specs = 2;
  total_size += 1UL * this->_internal_robot_specs_size();
  for (const auto& msg : this->_impl_.robot_specs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .SSL_GeometryData geometry = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.geometry_);
    }

    // optional .RealismConfig realism_config = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.realism_config_);
    }

    // optional uint32 vision_port = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vision_port());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimulatorConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SimulatorConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimulatorConfig::GetClassData() const { return &_class_data_; }


void SimulatorConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SimulatorConfig*>(&to_msg);
  auto& from = static_cast<const SimulatorConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SimulatorConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.robot_specs_.MergeFrom(from._impl_.robot_specs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_geometry()->::SSL_GeometryData::MergeFrom(
          from._internal_geometry());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_realism_config()->::RealismConfig::MergeFrom(
          from._internal_realism_config());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vision_port_ = from._impl_.vision_port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimulatorConfig::CopyFrom(const SimulatorConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SimulatorConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimulatorConfig::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.robot_specs_))
    return false;
  if (_internal_has_geometry()) {
    if (!_impl_.geometry_->IsInitialized()) return false;
  }
  return true;
}

void SimulatorConfig::InternalSwap(SimulatorConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.robot_specs_.InternalSwap(&other->_impl_.robot_specs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimulatorConfig, _impl_.vision_port_)
      + sizeof(SimulatorConfig::_impl_.vision_port_)
      - PROTOBUF_FIELD_OFFSET(SimulatorConfig, _impl_.geometry_)>(
          reinterpret_cast<char*>(&_impl_.geometry_),
          reinterpret_cast<char*>(&other->_impl_.geometry_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SimulatorConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[4]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::RobotLimits*
Arena::CreateMaybeMessage< ::RobotLimits >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RobotLimits >(arena);
}
template<> PROTOBUF_NOINLINE ::RobotWheelAngles*
Arena::CreateMaybeMessage< ::RobotWheelAngles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RobotWheelAngles >(arena);
}
template<> PROTOBUF_NOINLINE ::RobotSpecs*
Arena::CreateMaybeMessage< ::RobotSpecs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RobotSpecs >(arena);
}
template<> PROTOBUF_NOINLINE ::RealismConfig*
Arena::CreateMaybeMessage< ::RealismConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RealismConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::SimulatorConfig*
Arena::CreateMaybeMessage< ::SimulatorConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SimulatorConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
